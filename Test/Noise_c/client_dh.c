// server_dh.c — Noise + Classical DH baseline（X25519）

#include <limits.h>
#include <noise/protocol.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <time.h>
#include <ctype.h>
#include <strings.h>
#include <errno.h>

#define PORT 8888

static uint8_t message[65535 + 2];

static int load_key_fixed(const char *path, uint8_t *dst, size_t need) {
    FILE *fp = fopen(path, "rb");
    if (!fp) return 1;
    size_t r = fread(dst, 1, need, fp);
    fclose(fp);
    return r == need ? 0 : 2;
}

static double diff_ms(const struct timespec *t0, const struct timespec *t1) {
    const long sec = t1->tv_sec - t0->tv_sec;
    const long nsec = t1->tv_nsec - t0->tv_nsec;
    return (double)sec * 1000.0 + (double)nsec / 1e6;
}

static void usage(const char *prog) {
    fprintf(stderr,
        "Usage: %s PATTERN LABEL [KEM_IGNORED] [--iters N] [--warmup W] [--csv|--tsv] [--no-header] [--assert-dynamic]\n"
        "  This DH baseline always runs X25519.\n",
        prog);
}

int main(int argc, char *argv[])
{
    setvbuf(stdout, NULL, _IOLBF, 0);

    if(argc<3){ usage(argv[0]); return 1; }
    const char *pattern = argv[1];
    const char *label   = argv[2];

    int iters  = 1000;
    int warmup = 20;
    int header = 1;
    int assert_dynamic = 0;
    char sep   = ','; // default CSV

    for (int i = 3; i < argc; i++) {
        if (strncmp(argv[i],"--",2)!=0) continue;
        if (strcmp(argv[i], "--iters") == 0 && i+1 < argc) { iters = atoi(argv[++i]); }
        else if (strcmp(argv[i], "--warmup") == 0 && i+1 < argc) { warmup = atoi(argv[++i]); }
        else if (strcmp(argv[i], "--csv") == 0) { sep = ','; }
        else if (strcmp(argv[i], "--tsv") == 0) { sep = '\t'; }
        else if (strcmp(argv[i], "--no-header") == 0) { header = 0; }
        else if (strcmp(argv[i], "--assert-dynamic") == 0) { assert_dynamic = 1; }
    }

    if (iters <= 0) iters = 1;
    if (warmup < 0) warmup = 0;
    if (warmup > iters) warmup = iters;

// Optinal: Handshake name fixed to X25519/ChaChaPoly/BLAKE2s
    char to_test_full[64];
    snprintf(to_test_full, sizeof(to_test_full), "Noise_%s_25519_ChaChaPoly_BLAKE2s", pattern);

    // Read the static key (only for use with S/rs when needed)
    uint8_t client_private[32], client_public[32], server_public[32];
    if (load_key_fixed("./Keys/client_priv.txt", client_private, 32)) return 1;
    if (load_key_fixed("./Keys/client_pub.txt",  client_public,  32)) return 1;
    if (load_key_fixed("./Keys/server_pub.txt",  server_public,  32)) return 1;

    const char *kem_print = "X25519";

    
// Destination address and port: consistent with current namesapces script
    struct sockaddr_in server;
    memset(&server, 0, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr("10.0.0.1");
    server.sin_port = htons(PORT);

    if (header) {
        printf("role%cpattern%ckem%clabel%criter%clatency_ms%crc\n", sep,sep,sep,sep,sep,sep);
    }

    // Used for --assert-dynamic: previous handshake hash
    uint8_t last_h[64]; size_t last_hlen = 0;

    for(int i=0;i<iters;i++){
        int socket_desc = socket(AF_INET , SOCK_STREAM , 0);
        if (socket_desc == -1) { perror("socket"); return 1; }

        NoiseHandshakeState *handshake = NULL;
        NoiseDHState *dh;
        NoiseBuffer mbuf;
        size_t message_size, received;
        int err, action;
        struct timespec t0, t1;

        err = noise_handshakestate_new_by_name(&handshake, to_test_full, NOISE_ROLE_INITIATOR);
        if (err != NOISE_ERROR_NONE) { fprintf(stderr,"noise_new_by_name err=%d\n", err); return 1; }

        // Local static (ls) is provided on demand; ephemeral e is dynamically generated by the framework when writing E.
        if (noise_handshakestate_needs_local_keypair(handshake)){
            dh = noise_handshakestate_get_local_keypair_dh(handshake);
            err = noise_dhstate_set_keypair(dh, client_private, 32, client_public, 32);
            if (err != NOISE_ERROR_NONE) { fprintf(stderr,"set_keypair err=%d\n", err); return 1; }
        }
        // Preset the peer static only if the pattern requires a "pre-message" rs.
        if (noise_handshakestate_needs_remote_public_key(handshake)){
            dh = noise_handshakestate_get_remote_public_key_dh(handshake);
            err = noise_dhstate_set_public_key(dh, server_public, 32);
            if (err != NOISE_ERROR_NONE) { fprintf(stderr,"set_remote_pub err=%d\n", err); return 1; }
        }

        clock_gettime(CLOCK_MONOTONIC, &t0);
        if (connect(socket_desc , (struct sockaddr *)&server , sizeof(server)) < 0) {
            perror("connect"); close(socket_desc); noise_handshakestate_free(handshake); return 1;
        }

        int ok=1;
        err = noise_handshakestate_start(handshake);
        if (err != NOISE_ERROR_NONE) { ok=0; }

        while (ok) {
            action = noise_handshakestate_get_action(handshake);
            if (action == NOISE_ACTION_WRITE_MESSAGE) {
                noise_buffer_set_output(mbuf, message+2, sizeof(message)-2);
                err = noise_handshakestate_write_message(handshake, &mbuf, NULL);
                if (err != NOISE_ERROR_NONE) { ok=0; break; }
                message[0]=(uint8_t)(mbuf.size>>8); message[1]=(uint8_t)mbuf.size;
                size_t full = mbuf.size + 2, sent=0;
                while(full>0){
                    size_t chunk = full<1448? full:1448;
                    ssize_t w = send(socket_desc, message+sent, chunk, 0);
                    if (w<0){ ok=0; break; }
                    full -= (size_t)w; sent += (size_t)w;
                }
            } else if (action == NOISE_ACTION_READ_MESSAGE) {
                size_t need=1; received=0;
                while(received<need){
                    ssize_t r = recv(socket_desc, message+received, sizeof(message)-received, 0);
                    if (r<=0){ ok=0; break; }
                    message_size = (size_t)r;
                    if (need==1) { need = (message[0]<<8) + message[1] + 2; }
                    received += message_size;
                }
                if(!ok) break;
                noise_buffer_set_input(mbuf, message+2, received-2);
                err = noise_handshakestate_read_message(handshake, &mbuf, NULL);
                if (err != NOISE_ERROR_NONE) { ok=0; break; }
            } else if (action == NOISE_ACTION_SPLIT) {
                NoiseCipherState *send_cipher=0,*recv_cipher=0;
                err = noise_handshakestate_split(handshake,&send_cipher,&recv_cipher);
                if (err != NOISE_ERROR_NONE) { ok=0; break; }

                if (assert_dynamic) {
                    uint8_t hbuf[64];
                    int herr = noise_handshakestate_get_handshake_hash(handshake, hbuf, sizeof(hbuf));
                    if (herr == NOISE_ERROR_NONE) {
                        fprintf(stderr, "[client] iter=%d h[0..7]=%02x%02x%02x%02x%02x%02x%02x%02x\n",
                                i, hbuf[0],hbuf[1],hbuf[2],hbuf[3],hbuf[4],hbuf[5],hbuf[6],hbuf[7]);
                        if (last_hlen && memcmp(last_h, hbuf, last_hlen)==0) {
                            fprintf(stderr, "[WARN] client: handshake hash unchanged vs last iter — RNG/fixed-e suspected\n");
                        }
                        memcpy(last_h, hbuf, sizeof(hbuf));
                        last_hlen = sizeof(hbuf);
                    }
                }
                break;
            } else {
                break;
            }
        }

        clock_gettime(CLOCK_MONOTONIC, &t1);

        double ms = diff_ms(&t0, &t1);
        if (i >= warmup) {
            printf("%s%c%s%c%s%c%s%c%d%c%.3f%c%d\n",
                   "client", sep, pattern, sep, kem_print, sep, label, sep, i, sep, ms, sep, ok?0:1);
            fflush(stdout);
        }

        noise_handshakestate_free(handshake);
        close(socket_desc);
    }

    return 0;
}
